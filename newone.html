<!doctype html>
<html lang="he">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>משחק מירוצים – כביש אמיתי, בניינים, מטבעות!</title>
<style>
  html,body{height:100%;margin:0;overflow:hidden;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial;background:#111}
  #hud{position:fixed; left:12px; top:12px; color:#fff; font-weight:700;
    background:rgba(0,0,0,0.45); padding:10px 12px; border-radius:8px; z-index:10;}
  #controls{position:fixed; right:12px; top:12px; color:#fff; background:rgba(0,0,0,0.45);
    padding:10px 12px; border-radius:8px; z-index:10;}
  #msg{position:fixed; left:50%; transform:translateX(-50%); bottom:12px; color:#fff;
    background:rgba(0,0,0,0.45); padding:8px 10px; border-radius:6px; z-index:10}
  #coinCounter{position:fixed; right:12px; bottom:12px; color:#ff0; font-weight:700;
    background:rgba(0,0,0,0.45); padding:8px 12px; border-radius:8px; z-index:10;}
</style>
</head>
<body>
<div id="hud">מצב: <span id="modeName">--</span><br>מהירות: <span id="speed">0</span> קמ"ש<br>חיים: <span id="lives">3</span></div>
<div id="coinCounter">מטבעות: <span id="coins">0</span></div>

<script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>
<script>
// === משחק מירוצים 3D – כביש אמיתי עם קווים לבנים! ===
let mode = 'A';
const modeNameEl = document.getElementById('modeName');
const speedEl = document.getElementById('speed');
const livesEl = document.getElementById('lives');
const coinsEl = document.getElementById('coins');

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x8fc9ff);

// camera + renderer
const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 2000);
camera.position.set(0, 3.0, -8);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

// lights
const hemi = new THREE.HemisphereLight(0xffffff, 0x666666, 0.9); scene.add(hemi);
const sun = new THREE.DirectionalLight(0xffffff, 1.0); 
sun.position.set(-40,60,-20); 
sun.castShadow = true;
sun.shadow.mapSize.width = 2048;
sun.shadow.mapSize.height = 2048;
scene.add(sun);

// ground (large grass) - צבע הכביש שונה לשחור
const groundMat = new THREE.MeshStandardMaterial({color:0x000000, roughness:1});
const ground = new THREE.Mesh(new THREE.PlaneGeometry(4000,4000), groundMat);
ground.rotation.x = -Math.PI/2; 
ground.receiveShadow = true; 
scene.add(ground);

// --- כביש + קווים לבנים + גדרות אפורות ---
const pathGroup = new THREE.Group();
scene.add(pathGroup);

const pathPoints = [];
const R = 160;
for(let i=0;i<32;i++){
  const t = i/32 * Math.PI*2;
  const x = Math.cos(t)*(R + 20*Math.sin(2*t));
  const z = Math.sin(t)*(R + 20*Math.cos(3*t));
  pathPoints.push(new THREE.Vector3(x,0,z));
}

const curve = new THREE.CatmullRomCurve3(pathPoints);
curve.closed = true;

let leftBorderCurve = null, rightBorderCurve = null;

function buildRoad(){
  while(pathGroup.children.length) pathGroup.remove(pathGroup.children[0]);

  const halfW = 6.0;
  const laneWidth = halfW * 2 / 3;

  // כביש אפור
  const roadShape = new THREE.Shape();
  roadShape.moveTo(-halfW, 0);
  roadShape.lineTo(-halfW, -0.02);
  roadShape.lineTo(halfW, -0.02);
  roadShape.lineTo(halfW, 0);
  roadShape.closePath();

  const extrudeSettings = { steps: 256, bevelEnabled: false, extrudePath: curve };
  const roadGeo = new THREE.ExtrudeGeometry(roadShape, extrudeSettings);
  const roadMat = new THREE.MeshStandardMaterial({color:0x444444, roughness:0.8});
  const road = new THREE.Mesh(roadGeo, roadMat);
  road.position.y = 0.01;
  road.receiveShadow = true;
  pathGroup.add(road);

  // קו מרכזי – מקווקו
  const dashGeo = new THREE.PlaneGeometry(0.6, 4);
  const dashMat = new THREE.MeshStandardMaterial({color:0xffffff, side: THREE.DoubleSide});
  const dashSpacing = 8;
  const dashCount = Math.ceil(curve.getLength() / dashSpacing);

  for(let i = 0; i < dashCount; i++) {
    const t = (i * dashSpacing) / curve.getLength();
    const pos = curve.getPointAt(t);
    const tangent = curve.getTangentAt(t);
    const normal = new THREE.Vector3().crossVectors(new THREE.Vector3(0,1,0), tangent).normalize();

    const dash = new THREE.Mesh(dashGeo, dashMat);
    dash.position.copy(pos).addScaledVector(normal, 0).setY(0.03);
    dash.lookAt(pos.clone().add(tangent));
    dash.rotateX(Math.PI/2);
    pathGroup.add(dash);
  }

  // קווים צדדיים – רציפים
  const sideLineGeo = new THREE.PlaneGeometry(0.3, curve.getLength());
  const sideLineMat = new THREE.MeshStandardMaterial({color:0xffffff, side: THREE.DoubleSide});

  const leftLine = new THREE.Mesh(sideLineGeo, sideLineMat);
  leftLine.position.y = 0.03;
  leftLine.position.x = -halfW + 0.15;
  leftLine.rotation.y = Math.PI/2;
  pathGroup.add(leftLine);

  const rightLine = new THREE.Mesh(sideLineGeo, sideLineMat);
  rightLine.position.y = 0.03;
  rightLine.position.x = halfW - 0.15;
  rightLine.rotation.y = Math.PI/2;
  pathGroup.add(rightLine);

  // גדרות אפורות נמוכות
  const borderShape = new THREE.Shape();
  borderShape.moveTo(-0.25,0); borderShape.lineTo(0.25,0);
  borderShape.lineTo(0.25,0.6); borderShape.lineTo(-0.25,0.6);
  borderShape.closePath();

  const leftPoints = pathPoints.map(p => p.clone().add(computeRightVectorAtPoint(p).multiplyScalar(halfW + 0.6)));
  const rightPoints = pathPoints.map(p => p.clone().add(computeRightVectorAtPoint(p).multiplyScalar(-halfW - 0.6)));

  leftBorderCurve = new THREE.CatmullRomCurve3(leftPoints); leftBorderCurve.closed = true;
  rightBorderCurve = new THREE.CatmullRomCurve3(rightPoints); rightBorderCurve.closed = true;

  const borderMat = new THREE.MeshStandardMaterial({color:0x999999});
  const borderL = new THREE.Mesh(new THREE.ExtrudeGeometry(borderShape, {steps:256, bevelEnabled:false, extrudePath: leftBorderCurve}), borderMat);
  const borderR = new THREE.Mesh(new THREE.ExtrudeGeometry(borderShape, {steps:256, bevelEnabled:false, extrudePath: rightBorderCurve}), borderMat);
  pathGroup.add(borderL); pathGroup.add(borderR);

  removeBlackTallBorders();
}

function computeRightVectorAtPoint(p){
  let best = 0, bd = Infinity;
  for(let i=0;i<pathPoints.length;i++){
    const d = p.distanceToSquared(pathPoints[i]);
    if(d < bd){ bd = d; best = i; }
  }
  const a = pathPoints[best];
  const b = pathPoints[(best+1)%pathPoints.length];
  const dir = b.clone().sub(a).normalize();
  const right = new THREE.Vector3().crossVectors(new THREE.Vector3(0,1,0), dir).normalize();
  return right;
}

function removeBlackTallBorders(){
  const toRemove = [];
  pathGroup.children.forEach(child=>{
    if(!child.material || !child.geometry) return;
    const mat = child.material;
    if(mat.color && mat.color.r < 0.06 && mat.color.g < 0.06 && mat.color.b < 0.06){
      const geom = child.geometry;
      if(!geom.boundingBox) geom.computeBoundingBox();
      const height = geom.boundingBox.max.y - geom.boundingBox.min.y;
      if(height > 0.5) toRemove.push(child);
    }
  });
  toRemove.forEach(ch=>{ pathGroup.remove(ch); ch.geometry.dispose(); });
}
buildRoad();

// --- בניינים צבעוניים ---
const buildings = [];
function createBuilding(x, z, w, d, h, color) {
  const geo = new THREE.BoxGeometry(w, h, d);
  const mat = new THREE.MeshStandardMaterial({color, metalness:0.1, roughness:0.8});
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.set(x, h/2, z);
  mesh.castShadow = true;
  mesh.receiveShadow = true;
  scene.add(mesh);
  buildings.push(mesh);
}

// שמירה על 60 בניינים
for(let i = 0; i < 60; i++) {
  const angle = i / 60 * Math.PI * 2;
  const dist = R + 80 + Math.random() * 120;
  const x = Math.cos(angle) * dist;
  const z = Math.sin(angle) * dist;
  const w = 15 + Math.random() * 25;
  const d = 15 + Math.random() * 25;
  const h = 30 + Math.random() * 80;
  const hue = (i * 7) % 360;
  const color = new THREE.Color().setHSL(hue/360, 0.7, 0.5).getHex();
  createBuilding(x, z, w, d, h, color);
}

// --- מטבעות זהובים ---
const coins = [];
const coinGeometry = new THREE.CylinderGeometry(1.2, 1.2, 0.3, 16);
const coinMaterial = new THREE.MeshStandardMaterial({color:0xffd700, emissive:0xffaa00, emissiveIntensity:0.3, metalness:0.9, roughness:0.1});

// הפחתת מספר המטבעות ב-50%
function spawnCoin() {
  const t = Math.random();
  const center = curve.getPointAt(t);
  const dir = curve.getTangentAt(t);
  const right = new THREE.Vector3().crossVectors(new THREE.Vector3(0,1,0), dir).normalize();
  const offset = (Math.random() - 0.5) * 10;
  const pos = center.clone().addScaledVector(right, offset).setY(1.5);

  const coin = new THREE.Mesh(coinGeometry, coinMaterial);
  coin.position.copy(pos);
  coin.rotation.x = Math.PI/2;
  coin.castShadow = true;
  scene.add(coin);
  coins.push({mesh: coin, collected: false, spin: 0});
}

// הפחתת המטבעות ל-15
for(let i = 0; i < 15; i++) spawnCoin(); // שינית מ-30 ל-15
setInterval(() => { if(coins.length < 20) spawnCoin(); }, 3000); // שינית מ-40 ל-20

// --- רכב שחקן ---
function makeCar(color=0xff3333){
  const g = new THREE.Group();
  const body = new THREE.Mesh(new THREE.BoxGeometry(2.2,0.8,4), new THREE.MeshStandardMaterial({color, metalness:0.2, roughness:0.4}));
  body.position.y = 0.9; g.add(body);
  const wheelGeo = new THREE.CylinderGeometry(0.45,0.45,0.5,12); wheelGeo.rotateZ(Math.PI/2);
  for(let i=0;i<4;i++){
    const w = new THREE.Mesh(wheelGeo, new THREE.MeshStandardMaterial({color:0x111111}));
    const px = (i%2===0?-1:1); const pz = (i<2?1.4:-1.4);
    w.position.set(px,0.45,pz); g.add(w);
  }
  return g;
}
const player = makeCar(0xff4444);
player.position.set(pathPoints[0].x,0,pathPoints[0].z);
player.rotation.y = Math.PI;
scene.add(player);

// --- יריבים ---
const opponents = [];
for(let i=0;i<6;i++){
  const c = makeCar(new THREE.Color().setHSL(i/6,0.7,0.5).getHex());
  c.visible = false; scene.add(c); 
  opponents.push({mesh:c, t: i/6, speed: 30 + Math.random()*30});
}

// --- משתנים ---
let lives = 3, speed = 0, coinCount = 0;
const keys = {w:false,s:false,a:false,d:false,shift:false};

window.addEventListener('keydown', e=>{
  if(e.code === 'Digit1') setMode('A');
  if(e.code === 'Digit2') setMode('B');
  if(e.code === 'Digit3') setMode('C');
  if(e.code === 'KeyW') keys.w = true;
  if(e.code === 'KeyS') keys.s = true;
  if(e.code === 'KeyA') keys.a = true;
  if(e.code === 'KeyD') keys.d = true;
  if(e.code === 'ShiftLeft' || e.code === 'ShiftRight') keys.shift = true;
});
window.addEventListener('keyup', e=>{
  if(e.code === 'KeyW') keys.w = false;
  if(e.code === 'KeyS') keys.s = false;
  if(e.code === 'KeyA') keys.a = false;
  if(e.code === 'KeyD') keys.d = false;
  if(e.code === 'ShiftLeft' || e.code === 'ShiftRight') keys.shift = false;
});

function setMode(m){
  mode = m;
  modeNameEl.textContent = (m==='A'?'Infinite Arcade': m==='B'?'Closed Circuit':'Lane Arcade');
  lives = 3; speed = 0; coinCount = 0;
  livesEl.textContent = lives; speedEl.textContent = 0; coinsEl.textContent = 0;
  opponents.forEach((op, idx)=>{
    op.mesh.visible = true;
    op.t = (idx * 0.12 + 0.3) % 1;
    const p = pointOnPath(op.t);
    op.mesh.position.copy(p);
    op.mesh.rotation.y = 0;
  });
}
setMode('A');

function pointOnPath(t){
  const n = pathPoints.length;
  const f = (t*n) % n;
  const i = Math.floor(f);
  const a = pathPoints[i];
  const b = pathPoints[(i+1)%n];
  const local = f - i;
  return a.clone().lerp(b, local);
}

const ROAD_HALF_WIDTH = 6.0;
function clampPlayer(){
  let bestDist2 = Infinity, bestClosest = null, bestSegmentDir = null;
  for(let i=0;i<pathPoints.length;i++){
    const a = pathPoints[i];
    const b = pathPoints[(i+1) % pathPoints.length];
    const ab = b.clone().sub(a);
    const ap = player.position.clone().sub(a);
    const abLen2 = ab.lengthSq();
    let t = 0;
    if(abLen2 > 1e-6) t = Math.max(0, Math.min(1, ap.dot(ab) / abLen2));
    const closest = a.clone().addScaledVector(ab, t);
    const d2 = player.position.distanceToSquared(closest);
    if(d2 < bestDist2){
      bestDist2 = d2;
      bestClosest = closest;
      bestSegmentDir = ab.clone().normalize();
    }
  }
  if(!bestClosest) return;
  const right = new THREE.Vector3().crossVectors(new THREE.Vector3(0,1,0), bestSegmentDir).normalize();
  const lateralVec = player.position.clone().sub(bestClosest);
  const lateralDist = lateralVec.dot(right);
  const maxSide = ROAD_HALF_WIDTH - 0.01;
  if(Math.abs(lateralDist) > maxSide + 0.001){
    const corrected = bestClosest.clone().addScaledVector(right, Math.sign(lateralDist) * maxSide);
    player.position.x = corrected.x;
    player.position.z = corrected.z;
    player.position.y = 0;
  }
}

function pushFromBorders(){
  if(!leftBorderCurve || !rightBorderCurve) return;
  const p = player.position.clone();
  const tNear = findNearestTOnCurve(p, 256);
  const leftP = leftBorderCurve.getPointAt(tNear);
  const rightP = rightBorderCurve.getPointAt(tNear);
  const dL = p.distanceTo(leftP);
  const dR = p.distanceTo(rightP);
  const pushThreshold = 1.3;
  const pushStrength = 0.22;

  const centerP = curve.getPointAt(tNear);
  const nextCenter = curve.getPointAt((tNear + 0.002) % 1);
  const dir = nextCenter.clone().sub(centerP).normalize();
  const rightVec = new THREE.Vector3().crossVectors(new THREE.Vector3(0,1,0), dir).normalize();
  const lateralVec = player.position.clone().sub(centerP);
  const lateralDist = lateralVec.dot(rightVec);
  const maxSide = ROAD_HALF_WIDTH - 0.01;

  if(dL < pushThreshold){
    const away = player.position.clone().sub(leftP).setY(0);
    if(away.lengthSq() > 1e-6){
      away.normalize();
      const tentative = lateralDist + away.dot(rightVec) * pushStrength;
      const clampedLat = Math.max(-maxSide, Math.min(maxSide, tentative));
      const deltaLat = clampedLat - lateralDist;
      player.position.addScaledVector(rightVec, deltaLat);
    }
  }
  if(dR < pushThreshold){
    const away = player.position.clone().sub(rightP).setY(0);
    if(away.lengthSq() > 1e-6){
      away.normalize();
      const tentative = lateralDist + away.dot(rightVec) * pushStrength;
      const clampedLat = Math.max(-maxSide, Math.min(maxSide, tentative));
      const deltaLat = clampedLat - lateralDist;
      player.position.addScaledVector(rightVec, deltaLat);
    }
  }
}

function findNearestTOnCurve(p, samples=400){
  let bestT = 0, bestD = Infinity;
  for(let i=0;i<samples;i++){
    const t = i/(samples-1);
    const pt = curve.getPointAt(t);
    const d = pt.distanceToSquared(p);
    if(d < bestD){ bestD = d; bestT = t; }
  }
  return bestT;
}

function collisions(){
  opponents.forEach(op=>{
    const d = op.mesh.position.distanceTo(player.position);
    if(d < 2.2){
      speed *= 0.35;
      lives = Math.max(0, lives-1);
      livesEl.textContent = lives;
      const push = player.position.clone().sub(op.mesh.position).setY(0).normalize().multiplyScalar(0.8);
      player.position.add(push);
      // הוסרו השורות הקשורות ל-Game Over
    }
  });

  // איסוף מטבעות
  coins.forEach((c, i) => {
    if(c.collected) return;
    const d = c.mesh.position.distanceTo(player.position);
    if(d < 3){
      c.collected = true;
      c.mesh.visible = false;
      coinCount++;
      coinsEl.textContent = coinCount;
      scene.remove(c.mesh);
      coins.splice(i, 1);
    } else {
      c.spin += 0.05;
      c.mesh.rotation.z = c.spin;
    }
  });
}

const clock = new THREE.Clock();
function animate(){
  requestAnimationFrame(animate);
  const dt = Math.min(0.05, clock.getDelta());

  // תנועה
  if(keys.w) speed += 90 * dt * (keys.shift?1.4:1);
  else if(keys.s) speed -= 220 * dt;
  else speed -= 40 * dt;
  speed = Math.max(-15, Math.min(180 * (keys.shift?1.2:1), speed));
  const steer = (keys.a?1:0) - (keys.d?1:0);
  const turn = steer * 1.8 * dt * (speed/60 + 0.2);
  player.rotation.y += turn;
  const forward = new THREE.Vector3(0,0,-1).applyQuaternion(player.quaternion);
  const dist = (speed/3.6) * dt;
  player.position.addScaledVector(forward, dist);
  player.position.y = 0;

  // יריבים
  opponents.forEach((op, idx)=>{
    op.t = (op.t + (op.speed/3.6) * dt / 300) % 1;
    const p = pointOnPath(op.t);
    const off = ((idx%2)? -2.8:2.8);
    const nextp = pointOnPath((op.t + 0.01)%1);
    const dir = nextp.clone().sub(p).normalize();
    const right = new THREE.Vector3().crossVectors(new THREE.Vector3(0,1,0), dir).normalize();
    op.mesh.position.copy(p.clone().addScaledVector(right, off));
    op.mesh.rotation.y = Math.atan2(dir.x, dir.z);
  });

  pushFromBorders();
  clampPlayer();
  collisions();

  // מצלמה
  const camTarget = player.position.clone().add(new THREE.Vector3(0,1.2,0));
  const camOffset = new THREE.Vector3(0,3.2,8).applyQuaternion(player.quaternion);
  const desired = camTarget.clone().add(camOffset);
  camera.position.lerp(desired, 0.14);
  camera.lookAt(camTarget);

  speedEl.textContent = Math.round(speed);
  renderer.render(scene, camera);
}
animate();

window.addEventListener('resize', ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

console.log('כביש אמיתי עם קווים לבנים! בניינים, מטבעות – הכל   עובד!');
</script>
</body>
</html> 